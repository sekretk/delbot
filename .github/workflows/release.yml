name: Release Pipeline

on:
  push:
    tags:
      - '*.*.*'  # Triggers on version tags like v1.0.0, v2.1.3, etc.

env:
  REGISTRY: ghcr.io
  IMAGE_NAME_BACKEND: ${{ github.repository }}/backend
  IMAGE_NAME_FRONTEND: ${{ github.repository }}/frontend

jobs:
  build-and-push:
    name: Build & Push Docker Images
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    outputs:
      version: ${{ steps.version-info.outputs.version }}
      release-date: ${{ steps.version-info.outputs.release-date }}
      backend-image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }}:${{ steps.version-info.outputs.version }}
      frontend-image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }}:${{ steps.version-info.outputs.version }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        
      - name: Extract version and date
        id: version-info
        run: |
          VERSION=${GITHUB_REF#refs/tags/}
          RELEASE_DATE=$(date -u +"%Y-%m-%d")
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "release-date=$RELEASE_DATE" >> $GITHUB_OUTPUT
          
          echo "üì¶ Extracted Version: $VERSION"
          echo "üìÖ Release Date: $RELEASE_DATE"
          
      - name: Update version.ts file
        run: |
          echo "üîÑ Updating version.ts with release information..."
          
          cat > frontend/src/version.ts << EOF
          export const VERSION_INFO = {
            version: '${{ steps.version-info.outputs.version }}',
            releaseDate: '${{ steps.version-info.outputs.release-date }}',
            environment: 'production'
          } as const;
          
          export const getVersionString = () => \`v\${VERSION_INFO.version}\`;
          export const getReleaseDate = () => VERSION_INFO.releaseDate;
          export const getEnvironment = () => VERSION_INFO.environment;
          EOF
          
          echo "‚úÖ Updated version.ts:"
          cat frontend/src/version.ts
          
      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3
        
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Build and push backend Docker image
        run: |
          echo "üê≥ Building and pushing backend Docker image..."
          
          # Build backend image with version tag
          docker build -f backend/Dockerfile -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }}:${{ steps.version-info.outputs.version }} .
          
          # Tag as latest
          docker tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }}:${{ steps.version-info.outputs.version }} ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }}:latest
          
          # Push both tags
          docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }}:${{ steps.version-info.outputs.version }}
          docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }}:latest
          
          echo "‚úÖ Backend image pushed successfully!"
          
      - name: Build and push frontend Docker image  
        run: |
          echo "üê≥ Building and pushing frontend Docker image..."
          
          # Build frontend image with version tag
          docker build -f frontend/Dockerfile -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }}:${{ steps.version-info.outputs.version }} .
          
          # Tag as latest
          docker tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }}:${{ steps.version-info.outputs.version }} ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }}:latest
          
          # Push both tags
          docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }}:${{ steps.version-info.outputs.version }}
          docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }}:latest
          
          echo "‚úÖ Frontend image pushed successfully!"
          
      - name: Create build summary
        run: |
          echo "üéâ **Build & Push Complete!**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üì¶ Built Images" >> $GITHUB_STEP_SUMMARY
          echo "**Backend:**" >> $GITHUB_STEP_SUMMARY
          echo "- [\`${{ env.REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }}:${{ steps.version-info.outputs.version }}\`](https://github.com/${{ github.repository }}/pkgs/container/backend)" >> $GITHUB_STEP_SUMMARY
          echo "- [\`${{ env.REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }}:latest\`](https://github.com/${{ github.repository }}/pkgs/container/backend)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Frontend:**" >> $GITHUB_STEP_SUMMARY
          echo "- [\`${{ env.REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }}:${{ steps.version-info.outputs.version }}\`](https://github.com/${{ github.repository }}/pkgs/container/frontend)" >> $GITHUB_STEP_SUMMARY
          echo "- [\`${{ env.REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }}:latest\`](https://github.com/${{ github.repository }}/pkgs/container/frontend)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ **Images ready for deployment**" >> $GITHUB_STEP_SUMMARY

  deploy:
    name: Deploy to Kubernetes
    runs-on: ubuntu-latest
    needs: build-and-push
    if: success() && needs.build-and-push.result == 'success'
    permissions:
      contents: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        
      - name: Install kubectl
        run: |
          echo "‚öôÔ∏è Installing kubectl..."
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/
          echo "‚úÖ kubectl installed successfully!"
          kubectl version --client
          
      - name: Install Helm and jq
        run: |
          echo "‚öôÔ∏è Installing Helm..."
          curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
          echo "‚úÖ Helm installed successfully!"
          helm version
          
          echo "‚öôÔ∏è Installing jq for JSON parsing..."
          sudo apt-get update && sudo apt-get install -y jq
          echo "‚úÖ jq installed successfully!"
          
      - name: Setup Kubernetes cluster access
        env:
          KUBE_CONFIG: ${{ secrets.KUBE_CONFIG }}
        run: |
          if [ -n "$KUBE_CONFIG" ]; then
            echo "üîß Setting up Kubernetes cluster access..."
            mkdir -p ~/.kube
            echo "$KUBE_CONFIG" | base64 -d > ~/.kube/config
            chmod 600 ~/.kube/config
            
            # Test cluster connectivity
            if kubectl cluster-info > /dev/null 2>&1; then
              echo "‚úÖ Successfully connected to Kubernetes cluster"
              echo "KUBE_ACCESS=true" >> $GITHUB_ENV
            else
              echo "‚ùå Failed to connect to Kubernetes cluster"
              echo "KUBE_ACCESS=false" >> $GITHUB_ENV
            fi
          else
            echo "‚ö†Ô∏è KUBE_CONFIG secret not configured - skipping cluster setup"
            echo "KUBE_ACCESS=false" >> $GITHUB_ENV
          fi
          
      - name: Pre-deployment cluster inspection
        if: env.KUBE_ACCESS == 'true'
        run: |
          echo "üîç Pre-deployment cluster inspection..."
          echo "======================================"
          
          NAMESPACE="delbot"
          
          echo "üìä Cluster nodes:"
          kubectl get nodes -o wide || true
          
          echo ""
          echo "üìÅ Available namespaces:"
          kubectl get namespaces || true
          
          if kubectl get namespace "$NAMESPACE" >/dev/null 2>&1; then
            echo ""
            echo "‚úÖ Namespace '$NAMESPACE' exists"
            
            echo ""
            echo "üìã Current pods in '$NAMESPACE':"
            kubectl get pods -n "$NAMESPACE" -o wide || true
            
            echo ""
            echo "üìã Current services in '$NAMESPACE':"
            kubectl get services -n "$NAMESPACE" || true
            
            echo ""
            echo "üìã Current deployments in '$NAMESPACE':"
            kubectl get deployments -n "$NAMESPACE" -o wide || true
            
            echo ""
            echo "üìã Current Helm releases in '$NAMESPACE':"
            helm list -n "$NAMESPACE" || true
          else
            echo "‚ö†Ô∏è Namespace '$NAMESPACE' does not exist - will be created by Helm"
          fi
          
      - name: Clean up namespace conflicts
        if: env.KUBE_ACCESS == 'true'
        run: |
          echo "üßπ Checking and cleaning up namespace conflicts..."
          echo "================================================="
          
          NAMESPACE="delbot"
          
          # Check if namespace exists
          if kubectl get namespace "$NAMESPACE" >/dev/null 2>&1; then
            echo "üìÅ Namespace '$NAMESPACE' exists"
            
            # Check for conflicting Helm metadata
            HELM_RELEASE_NS=$(kubectl get namespace "$NAMESPACE" -o jsonpath='{.metadata.annotations.meta\.helm\.sh/release-namespace}' 2>/dev/null || echo "")
            HELM_RELEASE_NAME=$(kubectl get namespace "$NAMESPACE" -o jsonpath='{.metadata.annotations.meta\.helm\.sh/release-name}' 2>/dev/null || echo "")
            
            if [ -n "$HELM_RELEASE_NS" ] && [ "$HELM_RELEASE_NS" != "$NAMESPACE" ]; then
              echo "‚ö†Ô∏è Found conflicting Helm metadata:"
              echo "   Release namespace in annotation: $HELM_RELEASE_NS"
              echo "   Target namespace: $NAMESPACE"
              echo "   Release name: $HELM_RELEASE_NAME"
              
              echo "üßπ Cleaning up conflicting Helm annotations..."
              kubectl annotate namespace "$NAMESPACE" meta.helm.sh/release-namespace- 2>/dev/null || true
              kubectl annotate namespace "$NAMESPACE" meta.helm.sh/release-name- 2>/dev/null || true
              kubectl label namespace "$NAMESPACE" app.kubernetes.io/managed-by- 2>/dev/null || true
              
              echo "‚úÖ Conflicting annotations removed"
            else
              echo "‚úÖ No conflicting Helm metadata found"
            fi
            
            # Check for existing Helm releases in different namespaces
            echo ""
            echo "üîç Checking for existing 'delbot' releases in other namespaces..."
            EXISTING_RELEASES=$(helm list --all-namespaces -q | grep "^delbot$" || echo "")
            
            if [ -n "$EXISTING_RELEASES" ]; then
              echo "‚ö†Ô∏è Found existing 'delbot' releases:"
              helm list --all-namespaces | grep delbot || true
              
              echo ""
              echo "üóëÔ∏è Uninstalling conflicting releases..."
              # Uninstall any delbot releases in other namespaces
              helm list --all-namespaces --output json | jq -r '.[] | select(.name == "delbot") | "\(.namespace)"' | while read -r ns; do
                if [ "$ns" != "$NAMESPACE" ]; then
                  echo "Uninstalling delbot release from namespace: $ns"
                  helm uninstall delbot -n "$ns" || echo "Failed to uninstall from $ns"
                fi
              done
            else
              echo "‚úÖ No conflicting releases found"
            fi
          else
            echo "‚úÖ Namespace '$NAMESPACE' does not exist - will be created fresh"
          fi
          
      - name: Clean up namespace conflicts
        if: env.KUBE_ACCESS == 'true'
        run: |
          echo "üßπ Comprehensive namespace cleanup..."
          echo "===================================="
          
          NAMESPACE="delbot"
          
          # Check if namespace exists
          if kubectl get namespace "$NAMESPACE" >/dev/null 2>&1; then
            echo "üìÅ Namespace '$NAMESPACE' exists"
            
            # Check current Helm metadata
            HELM_MANAGED_BY=$(kubectl get namespace "$NAMESPACE" -o jsonpath='{.metadata.labels.app\.kubernetes\.io/managed-by}' 2>/dev/null || echo "")
            HELM_RELEASE_NS=$(kubectl get namespace "$NAMESPACE" -o jsonpath='{.metadata.annotations.meta\.helm\.sh/release-namespace}' 2>/dev/null || echo "")
            HELM_RELEASE_NAME=$(kubectl get namespace "$NAMESPACE" -o jsonpath='{.metadata.annotations.meta\.helm\.sh/release-name}' 2>/dev/null || echo "")
            
            echo "Current Helm metadata:"
            echo "  Managed by: '$HELM_MANAGED_BY'"
            echo "  Release namespace: '$HELM_RELEASE_NS'"
            echo "  Release name: '$HELM_RELEASE_NAME'"
            
            # Check if namespace has proper Helm ownership for this release
            if [ "$HELM_MANAGED_BY" != "Helm" ] || [ "$HELM_RELEASE_NS" != "$NAMESPACE" ] || [ "$HELM_RELEASE_NAME" != "delbot" ]; then
              echo "‚ö†Ô∏è Namespace lacks proper Helm metadata for 'delbot' release in '$NAMESPACE' namespace"
              
              # Add proper Helm metadata
              echo "üîß Adding proper Helm metadata..."
              kubectl label namespace "$NAMESPACE" app.kubernetes.io/managed-by=Helm --overwrite || true
              kubectl annotate namespace "$NAMESPACE" meta.helm.sh/release-name=delbot --overwrite || true
              kubectl annotate namespace "$NAMESPACE" meta.helm.sh/release-namespace="$NAMESPACE" --overwrite || true
              
              echo "‚úÖ Helm metadata updated"
            else
              echo "‚úÖ Namespace already has proper Helm metadata"
            fi
            
            # Check for existing Helm releases in different namespaces
            echo ""
            echo "üîç Checking for existing 'delbot' releases in other namespaces..."
            EXISTING_RELEASES=$(helm list --all-namespaces -q | grep "^delbot$" || echo "")
            
            if [ -n "$EXISTING_RELEASES" ]; then
              echo "‚ö†Ô∏è Found existing 'delbot' releases:"
              helm list --all-namespaces | grep delbot || true
              
              echo ""
              echo "üóëÔ∏è Uninstalling conflicting releases..."
              # Uninstall any delbot releases in other namespaces
              helm list --all-namespaces --output json | jq -r '.[] | select(.name == "delbot") | "\(.namespace)"' | while read -r ns; do
                if [ "$ns" != "$NAMESPACE" ]; then
                  echo "Uninstalling delbot release from namespace: $ns"
                  helm uninstall delbot -n "$ns" || echo "Failed to uninstall from $ns"
                fi
              done
            else
              echo "‚úÖ No conflicting releases found"
            fi
          else
            echo "‚úÖ Namespace '$NAMESPACE' does not exist - will be created fresh"
          fi
          
      - name: Deploy to Kubernetes with Helm (step by step)
        if: env.KUBE_ACCESS == 'true'
        run: |
          echo "üöÄ Deploying to Kubernetes step by step..."
          echo "=========================================="
          
          NAMESPACE="delbot"
          VERSION="${{ needs.build-and-push.outputs.version }}"
          
          echo "üìã Deployment Configuration:"
          echo "Namespace: $NAMESPACE"
          echo "Version: $VERSION"
          echo "Chart Path: ./delbot-chart"
          echo ""
          
          # Step 1: Validate chart
          echo "Step 1: Validating Helm chart..."
          helm lint ./delbot-chart || {
            echo "‚ùå Helm chart validation failed"
            exit 1
          }
          echo "‚úÖ Helm chart validation passed"
          echo ""
          
          # Step 2: Template generation (to verify configuration)
          echo "Step 2: Generating Helm templates..."
          helm template delbot ./delbot-chart \
            --namespace "$NAMESPACE" \
            --set backend.image.tag="$VERSION" \
            --set frontend.image.tag="$VERSION" \
            --set commonLabels.version="$VERSION" \
            --debug > /tmp/delbot-manifest.yaml
          echo "‚úÖ Helm templates generated successfully"
          
          echo "Generated manifest preview (first 50 lines):"
          head -50 /tmp/delbot-manifest.yaml
          echo "... (truncated)"
          echo ""
          
          # Step 3: Actual deployment (without wait)
          echo "Step 3: Executing Helm deployment..."
          helm upgrade --install delbot ./delbot-chart \
            --namespace "$NAMESPACE" \
            --set backend.image.tag="$VERSION" \
            --set frontend.image.tag="$VERSION" \
            --set commonLabels.version="$VERSION" \
            --wait=false \
            --debug
            
          if [ $? -eq 0 ]; then
            echo "‚úÖ Helm deployment command executed successfully"
          else
            echo "‚ùå Helm deployment command failed"
            exit 1
          fi
          
      - name: Monitor deployment progress
        if: env.KUBE_ACCESS == 'true'
        run: |
          echo "‚è≥ Monitoring deployment progress..."
          echo "==================================="
          
          NAMESPACE="delbot"
          
          # Wait a moment for resources to be created
          sleep 10
          
          echo "üìä Deployment status:"
          kubectl get deployments -n "$NAMESPACE" -o wide || true
          
          echo ""
          echo "üìã Pod status:"
          kubectl get pods -n "$NAMESPACE" -o wide || true
          
          echo ""
          echo "üìã Service status:"
          kubectl get services -n "$NAMESPACE" || true
          
          echo ""
          echo "üìã Recent events:"
          kubectl get events -n "$NAMESPACE" --sort-by='.lastTimestamp' | tail -20 || true
          
          # Try to wait for deployments with shorter timeout
          echo ""
          echo "‚è≥ Waiting for deployments (with 180s timeout)..."
          
          if kubectl wait --for=condition=available --timeout=180s deployment/delbot-backend -n "$NAMESPACE" 2>/dev/null; then
            echo "‚úÖ Backend deployment is ready"
          else
            echo "‚ö†Ô∏è Backend deployment not ready within timeout"
            kubectl describe deployment delbot-backend -n "$NAMESPACE" || true
          fi
          
          if kubectl wait --for=condition=available --timeout=180s deployment/delbot-frontend -n "$NAMESPACE" 2>/dev/null; then
            echo "‚úÖ Frontend deployment is ready"
          else
            echo "‚ö†Ô∏è Frontend deployment not ready within timeout"
            kubectl describe deployment delbot-frontend -n "$NAMESPACE" || true
          fi
          
      - name: Post-deployment inspection
        if: always() && env.KUBE_ACCESS == 'true'
        run: |
          echo "üîç Post-deployment inspection..."
          echo "==============================="
          
          NAMESPACE="delbot"
          
          echo "üìä Final deployment status:"
          kubectl get all -n "$NAMESPACE" || true
          
          echo ""
          echo "üìã Pod details:"
          kubectl describe pods -n "$NAMESPACE" | grep -E "(Name:|Status:|Image:|Events:)" || true
          
          echo ""
          echo "üìã Recent events (last 10):"
          kubectl get events -n "$NAMESPACE" --sort-by='.lastTimestamp' | tail -10 || true
          
          echo ""
          echo "üè∑Ô∏è Deployed image versions:"
          kubectl get deployment delbot-backend -n "$NAMESPACE" -o jsonpath='{.spec.template.spec.containers[0].image}' 2>/dev/null && echo " (Backend)" || echo "Backend deployment not found"
          kubectl get deployment delbot-frontend -n "$NAMESPACE" -o jsonpath='{.spec.template.spec.containers[0].image}' 2>/dev/null && echo " (Frontend)" || echo "Frontend deployment not found"
          
          echo ""
          echo "üìã Helm release status:"
          helm status delbot -n "$NAMESPACE" || echo "Helm release not found"
          
      - name: Create release summary
        run: |
          echo "üéâ **Release ${{ needs.build-and-push.outputs.version }} Complete!**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üìã Release Details" >> $GITHUB_STEP_SUMMARY
          echo "- **Version:** ${{ needs.build-and-push.outputs.version }}" >> $GITHUB_STEP_SUMMARY  
          echo "- **Date:** ${{ needs.build-and-push.outputs.release-date }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Git SHA:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment:** production" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ‚úÖ Completed Tasks" >> $GITHUB_STEP_SUMMARY
          echo "- [x] Extracted version from tag" >> $GITHUB_STEP_SUMMARY
          echo "- [x] Updated version.ts file" >> $GITHUB_STEP_SUMMARY
          echo "- [x] Built and pushed backend Docker image" >> $GITHUB_STEP_SUMMARY
          echo "- [x] Built and pushed frontend Docker image" >> $GITHUB_STEP_SUMMARY
          echo "- [x] Installed kubectl and Helm" >> $GITHUB_STEP_SUMMARY
          if [ "${{ env.KUBE_ACCESS }}" == "true" ]; then
            echo "- [x] Deployed to Kubernetes cluster successfully" >> $GITHUB_STEP_SUMMARY
          else
            echo "- [ ] Kubernetes deployment (cluster access not configured)" >> $GITHUB_STEP_SUMMARY
          fi
          if [ -n "${{ secrets.DELBOT_TOKEN }}" ] && [ -n "${{ secrets.DELBOT_WORKGROUP_CHANNEL }}" ]; then
            echo "- [x] Telegram release notification sent" >> $GITHUB_STEP_SUMMARY
          else
            echo "- [ ] Telegram notification (secrets not configured)" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üê≥ Docker Images Published" >> $GITHUB_STEP_SUMMARY
          echo "**Backend:**" >> $GITHUB_STEP_SUMMARY
          echo "- [\`${{ needs.build-and-push.outputs.backend-image }}\`](https://github.com/${{ github.repository }}/pkgs/container/backend)" >> $GITHUB_STEP_SUMMARY
          echo "- [\`${{ env.REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }}:latest\`](https://github.com/${{ github.repository }}/pkgs/container/backend)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Frontend:**" >> $GITHUB_STEP_SUMMARY
          echo "- [\`${{ needs.build-and-push.outputs.frontend-image }}\`](https://github.com/${{ github.repository }}/pkgs/container/frontend)" >> $GITHUB_STEP_SUMMARY
          echo "- [\`${{ env.REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }}:latest\`](https://github.com/${{ github.repository }}/pkgs/container/frontend)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ env.KUBE_ACCESS }}" == "true" ]; then
            echo "### üöÄ Live Application" >> $GITHUB_STEP_SUMMARY
            echo "**DelBot ${{ needs.build-and-push.outputs.version }} is now live!**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "- üåê **Frontend:** [http://delbot.boysthings.top/](http://delbot.boysthings.top/)" >> $GITHUB_STEP_SUMMARY
            echo "- üîß **Backend API:** [http://delbot.boysthings.top/api/health](http://delbot.boysthings.top/api/health)" >> $GITHUB_STEP_SUMMARY
            echo "- ‚ù§Ô∏è **Health Check:** [http://delbot.boysthings.top/health](http://delbot.boysthings.top/health)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### üìä Kubernetes Status" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
            echo "# Check deployment status" >> $GITHUB_STEP_SUMMARY
            echo "helm status delbot" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "# View pods" >> $GITHUB_STEP_SUMMARY
            echo "kubectl get pods -n delbot" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          else
            echo "### üöÄ Manual Deployment" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
            echo "# Deploy manually using Helm" >> $GITHUB_STEP_SUMMARY
            echo "./deploy.sh --version ${{ needs.build-and-push.outputs.version }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "# Or using Docker" >> $GITHUB_STEP_SUMMARY
            echo "docker pull ${{ needs.build-and-push.outputs.backend-image }}" >> $GITHUB_STEP_SUMMARY  
            echo "docker pull ${{ needs.build-and-push.outputs.frontend-image }}" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          fi
          
      - name: Send Telegram Release Notification
        env:
          DELBOT_TOKEN: ${{ secrets.DELBOT_TOKEN }}
          DELBOT_WORKGROUP_CHANNEL: ${{ secrets.DELBOT_WORKGROUP_CHANNEL }}
        run: |
          if [ -n "$DELBOT_TOKEN" ] && [ -n "$DELBOT_WORKGROUP_CHANNEL" ]; then
            echo "üì± Sending Telegram release notification..."
            
            # Prepare deployment status message
            if [ "${{ env.KUBE_ACCESS }}" == "true" ]; then
              DEPLOY_STATUS="‚úÖ *Automatically deployed to Kubernetes*"
              APP_LINKS="
              üåê *Live Application:*
              ‚Ä¢ [Frontend](http://delbot.boysthings.top/)
              ‚Ä¢ [Backend API](http://delbot.boysthings.top/api/health)
              ‚Ä¢ [Health Check](http://delbot.boysthings.top/health)"
            else
              DEPLOY_STATUS="üì¶ *Docker images published* (manual deployment required)"
              APP_LINKS="
              üöÄ *Deploy manually:*
              \`./deploy.sh --version ${{ needs.build-and-push.outputs.version }}\`"
            fi
            
            # Create release message
            MESSAGE="ü§ñ *DelBot Release ${{ needs.build-and-push.outputs.version }}* üöÄ
            
            üìÖ *Date:* ${{ needs.build-and-push.outputs.release-date }}
            üè∑Ô∏è *Version:* ${{ needs.build-and-push.outputs.version }}
            üìù *Commit:* [\`${GITHUB_SHA:0:7}\`](https://github.com/${{ github.repository }}/commit/${{ github.sha }})
            
            ${DEPLOY_STATUS}${APP_LINKS}
            
            üê≥ *Docker Images Published:*
            ‚Ä¢ \`${{ needs.build-and-push.outputs.backend-image }}\`
            ‚Ä¢ \`${{ needs.build-and-push.outputs.frontend-image }}\`
            
            üìã *Release Details:*
            [View on GitHub](https://github.com/${{ github.repository }}/releases/tag/${{ github.ref_name }})
            
            *Release pipeline completed successfully!* ‚ú®"
            
            # Send notification
            curl -s -X POST "https://api.telegram.org/bot${DELBOT_TOKEN}/sendMessage" \
              -d chat_id="${DELBOT_WORKGROUP_CHANNEL}" \
              -d parse_mode="Markdown" \
              -d text="$MESSAGE" \
              -d disable_web_page_preview="true"
            
            if [ $? -eq 0 ]; then
              echo "‚úÖ Telegram notification sent successfully!"
            else
              echo "‚ùå Failed to send Telegram notification"
            fi
          else
            echo "‚ö†Ô∏è Telegram secrets not configured - skipping notification"
          fi
          
      - name: Display version file
        run: |
          echo "üìÑ Final version.ts content:"
          echo "================================"
          cat frontend/src/version.ts
          echo "================================"