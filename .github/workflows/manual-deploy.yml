name: Manual Deployment

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to deploy (e.g., 0.0.11)'
        required: true
        default: '0.0.11'
        type: string
      namespace:
        description: 'Kubernetes namespace'
        required: false
        default: 'delbot'
        type: string
      debug:
        description: 'Enable debug mode'
        required: false
        default: true
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_NAME_BACKEND: ${{ github.repository }}/backend
  IMAGE_NAME_FRONTEND: ${{ github.repository }}/frontend

jobs:
  manual-deploy:
    name: Manual Kubernetes Deployment
    runs-on: ubuntu-latest
    permissions:
      contents: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        
      - name: Display deployment parameters
        run: |
          echo "üéØ **Manual Deployment Parameters**"
          echo "=================================="
          echo "üì¶ Version: ${{ github.event.inputs.version }}"
          echo "üìÅ Namespace: ${{ github.event.inputs.namespace }}"
          echo "üêõ Debug Mode: ${{ github.event.inputs.debug }}"
          echo ""
          echo "üê≥ Target Images:"
          echo "Backend:  ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }}:${{ github.event.inputs.version }}"
          echo "Frontend: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }}:${{ github.event.inputs.version }}"
        
      - name: Verify Docker images exist
        run: |
          echo "üîç Verifying Docker images exist in registry..."
          
          BACKEND_IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }}:${{ github.event.inputs.version }}"
          FRONTEND_IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }}:${{ github.event.inputs.version }}"
          
          echo "Checking backend image: $BACKEND_IMAGE"
          if docker manifest inspect "$BACKEND_IMAGE" >/dev/null 2>&1; then
            echo "‚úÖ Backend image exists and is accessible"
          else
            echo "‚ùå Backend image not found or not accessible"
            echo "Please ensure the image exists: $BACKEND_IMAGE"
            exit 1
          fi
          
          echo "Checking frontend image: $FRONTEND_IMAGE"
          if docker manifest inspect "$FRONTEND_IMAGE" >/dev/null 2>&1; then
            echo "‚úÖ Frontend image exists and is accessible"
          else
            echo "‚ùå Frontend image not found or not accessible"
            echo "Please ensure the image exists: $FRONTEND_IMAGE"
            exit 1
          fi
          
      - name: Install kubectl
        run: |
          echo "‚öôÔ∏è Installing kubectl..."
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/
          echo "‚úÖ kubectl installed successfully!"
          kubectl version --client
          
      - name: Install Helm and jq
        run: |
          echo "‚öôÔ∏è Installing Helm..."
          curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
          echo "‚úÖ Helm installed successfully!"
          helm version
          
          echo "‚öôÔ∏è Installing jq for JSON parsing..."
          sudo apt-get update && sudo apt-get install -y jq
          echo "‚úÖ jq installed successfully!"
          
      - name: Setup Kubernetes cluster access
        env:
          KUBE_CONFIG: ${{ secrets.KUBE_CONFIG }}
        run: |
          if [ -n "$KUBE_CONFIG" ]; then
            echo "üîß Setting up Kubernetes cluster access..."
            mkdir -p ~/.kube
            echo "$KUBE_CONFIG" | base64 -d > ~/.kube/config
            chmod 600 ~/.kube/config
            
            # Test cluster connectivity
            if kubectl cluster-info > /dev/null 2>&1; then
              echo "‚úÖ Successfully connected to Kubernetes cluster"
              echo "KUBE_ACCESS=true" >> $GITHUB_ENV
            else
              echo "‚ùå Failed to connect to Kubernetes cluster"
              echo "KUBE_ACCESS=false" >> $GITHUB_ENV
              exit 1
            fi
          else
            echo "‚ùå KUBE_CONFIG secret not configured"
            exit 1
          fi
          
      - name: Pre-deployment cluster inspection
        if: env.KUBE_ACCESS == 'true'
        run: |
          echo "üîç Pre-deployment cluster inspection..."
          echo "======================================"
          
          NAMESPACE="${{ github.event.inputs.namespace }}"
          
          echo "üìä Cluster nodes:"
          kubectl get nodes -o wide || true
          
          echo ""
          echo "üìÅ Available namespaces:"
          kubectl get namespaces || true
          
          if kubectl get namespace "$NAMESPACE" >/dev/null 2>&1; then
            echo ""
            echo "‚úÖ Namespace '$NAMESPACE' exists"
            
            echo ""
            echo "üìã Current pods in '$NAMESPACE':"
            kubectl get pods -n "$NAMESPACE" -o wide || true
            
            echo ""
            echo "üìã Current services in '$NAMESPACE':"
            kubectl get services -n "$NAMESPACE" || true
            
            echo ""
            echo "üìã Current deployments in '$NAMESPACE':"
            kubectl get deployments -n "$NAMESPACE" -o wide || true
            
            echo ""
            echo "üìã Current Helm releases in '$NAMESPACE':"
            helm list -n "$NAMESPACE" || true
          else
            echo "‚ö†Ô∏è Namespace '$NAMESPACE' does not exist - will be created by Helm"
          fi
          
      - name: Clean up namespace conflicts
        if: env.KUBE_ACCESS == 'true'
        run: |
          echo "üßπ Checking and cleaning up namespace conflicts..."
          echo "================================================="
          
          NAMESPACE="${{ github.event.inputs.namespace }}"
          
          # Check if namespace exists
          if kubectl get namespace "$NAMESPACE" >/dev/null 2>&1; then
            echo "üìÅ Namespace '$NAMESPACE' exists"
            
            # Check for conflicting Helm metadata
            HELM_RELEASE_NS=$(kubectl get namespace "$NAMESPACE" -o jsonpath='{.metadata.annotations.meta\.helm\.sh/release-namespace}' 2>/dev/null || echo "")
            HELM_RELEASE_NAME=$(kubectl get namespace "$NAMESPACE" -o jsonpath='{.metadata.annotations.meta\.helm\.sh/release-name}' 2>/dev/null || echo "")
            
            if [ -n "$HELM_RELEASE_NS" ] && [ "$HELM_RELEASE_NS" != "$NAMESPACE" ]; then
              echo "‚ö†Ô∏è Found conflicting Helm metadata:"
              echo "   Release namespace in annotation: $HELM_RELEASE_NS"
              echo "   Target namespace: $NAMESPACE"
              echo "   Release name: $HELM_RELEASE_NAME"
              
              echo "üßπ Cleaning up conflicting Helm annotations..."
              kubectl annotate namespace "$NAMESPACE" meta.helm.sh/release-namespace- 2>/dev/null || true
              kubectl annotate namespace "$NAMESPACE" meta.helm.sh/release-name- 2>/dev/null || true
              kubectl label namespace "$NAMESPACE" app.kubernetes.io/managed-by- 2>/dev/null || true
              
              echo "‚úÖ Conflicting annotations removed"
            else
              echo "‚úÖ No conflicting Helm metadata found"
            fi
            
            # Check for existing Helm releases in different namespaces
            echo ""
            echo "üîç Checking for existing 'delbot' releases in other namespaces..."
            EXISTING_RELEASES=$(helm list --all-namespaces -q | grep "^delbot$" || echo "")
            
            if [ -n "$EXISTING_RELEASES" ]; then
              echo "‚ö†Ô∏è Found existing 'delbot' releases:"
              helm list --all-namespaces | grep delbot || true
              
              echo ""
              echo "üóëÔ∏è Uninstalling conflicting releases..."
              # Uninstall any delbot releases in other namespaces
              helm list --all-namespaces --output json | jq -r '.[] | select(.name == "delbot") | "\(.namespace)"' | while read -r ns; do
                if [ "$ns" != "$NAMESPACE" ]; then
                  echo "Uninstalling delbot release from namespace: $ns"
                  helm uninstall delbot -n "$ns" || echo "Failed to uninstall from $ns"
                fi
              done
            else
              echo "‚úÖ No conflicting releases found"
            fi
          else
            echo "‚úÖ Namespace '$NAMESPACE' does not exist - will be created fresh"
          fi
          
      - name: Deploy to Kubernetes with Helm (step by step)
        if: env.KUBE_ACCESS == 'true'
        run: |
          echo "üöÄ Deploying to Kubernetes step by step..."
          echo "=========================================="
          
          NAMESPACE="${{ github.event.inputs.namespace }}"
          VERSION="${{ github.event.inputs.version }}"
          DEBUG_FLAG=""
          
          if [ "${{ github.event.inputs.debug }}" == "true" ]; then
            DEBUG_FLAG="--debug"
          fi
          
          echo "üìã Deployment Configuration:"
          echo "Namespace: $NAMESPACE"
          echo "Version: $VERSION"
          echo "Debug: ${{ github.event.inputs.debug }}"
          echo "Chart Path: ./delbot-chart"
          echo ""
          
          # Step 1: Validate chart
          echo "Step 1: Validating Helm chart..."
          helm lint ./delbot-chart || {
            echo "‚ùå Helm chart validation failed"
            exit 1
          }
          echo "‚úÖ Helm chart validation passed"
          echo ""
          
          # Step 2: Template generation (to verify configuration)
          echo "Step 2: Generating Helm templates..."
          helm template delbot ./delbot-chart \
            --namespace "$NAMESPACE" \
            --set backend.image.tag="$VERSION" \
            --set frontend.image.tag="$VERSION" \
            --set commonLabels.version="$VERSION" \
            $DEBUG_FLAG > /tmp/delbot-manifest.yaml
          echo "‚úÖ Helm templates generated successfully"
          
          if [ "${{ github.event.inputs.debug }}" == "true" ]; then
            echo "Generated manifest preview (first 50 lines):"
            head -50 /tmp/delbot-manifest.yaml
            echo "... (truncated)"
            echo ""
          fi
          
          # Step 3: Actual deployment (without wait)
          echo "Step 3: Executing Helm deployment..."
          helm upgrade --install delbot ./delbot-chart \
            --namespace "$NAMESPACE" \
            --create-namespace \
            --set backend.image.tag="$VERSION" \
            --set frontend.image.tag="$VERSION" \
            --set commonLabels.version="$VERSION" \
            --wait=false \
            $DEBUG_FLAG
            
          if [ $? -eq 0 ]; then
            echo "‚úÖ Helm deployment command executed successfully"
          else
            echo "‚ùå Helm deployment command failed"
            exit 1
          fi
          
      - name: Monitor deployment progress
        if: env.KUBE_ACCESS == 'true'
        run: |
          echo "‚è≥ Monitoring deployment progress..."
          echo "==================================="
          
          NAMESPACE="${{ github.event.inputs.namespace }}"
          
          # Wait a moment for resources to be created
          sleep 10
          
          echo "üìä Deployment status:"
          kubectl get deployments -n "$NAMESPACE" -o wide || true
          
          echo ""
          echo "üìã Pod status:"
          kubectl get pods -n "$NAMESPACE" -o wide || true
          
          echo ""
          echo "üìã Service status:"
          kubectl get services -n "$NAMESPACE" || true
          
          echo ""
          echo "üìã Recent events:"
          kubectl get events -n "$NAMESPACE" --sort-by='.lastTimestamp' | tail -20 || true
          
          # Try to wait for deployments with shorter timeout
          echo ""
          echo "‚è≥ Waiting for deployments (with 180s timeout)..."
          
          if kubectl wait --for=condition=available --timeout=180s deployment/delbot-backend -n "$NAMESPACE" 2>/dev/null; then
            echo "‚úÖ Backend deployment is ready"
          else
            echo "‚ö†Ô∏è Backend deployment not ready within timeout"
            kubectl describe deployment delbot-backend -n "$NAMESPACE" || true
          fi
          
          if kubectl wait --for=condition=available --timeout=180s deployment/delbot-frontend -n "$NAMESPACE" 2>/dev/null; then
            echo "‚úÖ Frontend deployment is ready"
          else
            echo "‚ö†Ô∏è Frontend deployment not ready within timeout"
            kubectl describe deployment delbot-frontend -n "$NAMESPACE" || true
          fi
          
      - name: Post-deployment inspection
        if: always() && env.KUBE_ACCESS == 'true'
        run: |
          echo "üîç Post-deployment inspection..."
          echo "==============================="
          
          NAMESPACE="${{ github.event.inputs.namespace }}"
          
          echo "üìä Final deployment status:"
          kubectl get all -n "$NAMESPACE" || true
          
          echo ""
          echo "üìã Pod details:"
          kubectl describe pods -n "$NAMESPACE" | grep -E "(Name:|Status:|Image:|Events:)" || true
          
          echo ""
          echo "üìã Recent events (last 10):"
          kubectl get events -n "$NAMESPACE" --sort-by='.lastTimestamp' | tail -10 || true
          
          echo ""
          echo "üè∑Ô∏è Deployed image versions:"
          kubectl get deployment delbot-backend -n "$NAMESPACE" -o jsonpath='{.spec.template.spec.containers[0].image}' 2>/dev/null && echo " (Backend)" || echo "Backend deployment not found"
          kubectl get deployment delbot-frontend -n "$NAMESPACE" -o jsonpath='{.spec.template.spec.containers[0].image}' 2>/dev/null && echo " (Frontend)" || echo "Frontend deployment not found"
          
          echo ""
          echo "üìã Helm release status:"
          helm status delbot -n "$NAMESPACE" || echo "Helm release not found"
          
      - name: Create deployment summary
        if: always()
        run: |
          echo "üìã **Manual Deployment Summary**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üéØ Deployment Parameters" >> $GITHUB_STEP_SUMMARY
          echo "- **Version:** ${{ github.event.inputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Namespace:** ${{ github.event.inputs.namespace }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Debug Mode:** ${{ github.event.inputs.debug }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ env.KUBE_ACCESS }}" == "true" ]; then
            echo "- [x] ‚úÖ Cluster connectivity: **SUCCESS**" >> $GITHUB_STEP_SUMMARY
            
            # Try to determine if deployment was successful
            NAMESPACE="${{ github.event.inputs.namespace }}"
            if kubectl get deployment delbot-backend -n "$NAMESPACE" >/dev/null 2>&1 && kubectl get deployment delbot-frontend -n "$NAMESPACE" >/dev/null 2>&1; then
              echo "- [x] ‚úÖ Deployment executed: **SUCCESS**" >> $GITHUB_STEP_SUMMARY
            else
              echo "- [ ] ‚ùå Deployment executed: **FAILED**" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "- [ ] ‚ùå Cluster connectivity: **FAILED**" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üê≥ Target Images" >> $GITHUB_STEP_SUMMARY
          echo "- **Backend:** \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }}:${{ github.event.inputs.version }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Frontend:** \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }}:${{ github.event.inputs.version }}\`" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ env.KUBE_ACCESS }}" == "true" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### üîç Troubleshooting Commands" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
            echo "# Check deployment status" >> $GITHUB_STEP_SUMMARY
            echo "kubectl get pods -n ${{ github.event.inputs.namespace }}" >> $GITHUB_STEP_SUMMARY
            echo "kubectl get deployments -n ${{ github.event.inputs.namespace }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "# Check logs" >> $GITHUB_STEP_SUMMARY
            echo "kubectl logs -l app=delbot-backend -n ${{ github.event.inputs.namespace }}" >> $GITHUB_STEP_SUMMARY
            echo "kubectl logs -l app=delbot-frontend -n ${{ github.event.inputs.namespace }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "# Check events" >> $GITHUB_STEP_SUMMARY
            echo "kubectl get events -n ${{ github.event.inputs.namespace }} --sort-by='.lastTimestamp'" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "# Helm status" >> $GITHUB_STEP_SUMMARY
            echo "helm status delbot -n ${{ github.event.inputs.namespace }}" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          fi
